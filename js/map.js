// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  this.Map = (function() {
    var adjacentCoordinates, coorForKey, drawLitTile, flatten, generateTiles, generateWalls, keyify;

    function Map(display) {
      this.display = display;
      this.isAFloorSpace = __bind(this.isAFloorSpace, this);
      this.drawAt = __bind(this.drawAt, this);
      this.drawFOV = __bind(this.drawFOV, this);
      this.tiles = generateTiles();
    }

    Map.prototype.drawAll = function() {
      var coor, _results;
      _results = [];
      for (coor in this.tiles) {
        _results.push(this.drawAt.apply(this, coorForKey(coor)));
      }
      return _results;
    };

    Map.prototype.drawFOV = function(fov) {
      var x, y, _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = fov.length; _i < _len; _i++) {
        _ref = fov[_i], x = _ref[0], y = _ref[1];
        _results.push(drawLitTile(keyify(x, y), this));
      }
      return _results;
    };

    Map.prototype.drawAt = function(x, y) {
      return this.display.draw(x, y, this.tiles[keyify(x, y)]);
    };

    Map.prototype.randomFloorSpace = function() {
      var f, floor;
      floor = (function() {
        var _results;
        _results = [];
        for (f in this.tiles) {
          if (this.tiles[f] === '.') {
            _results.push(f);
          }
        }
        return _results;
      }).call(this);
      return coorForKey(floor.randomize()[0]);
    };

    Map.prototype.isAFloorSpace = function(x, y) {
      return this.tiles[keyify(x, y)] === '.';
    };

    generateTiles = function() {
      var differ, key, tiles, _i, _len, _ref;
      tiles = {};
      differ = new ROT.Map.Digger();
      differ.create(function(x, y, wall) {
        if (!wall) {
          return tiles[keyify(x, y)] = '.';
        }
      });
      _ref = generateWalls(tiles);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        tiles[key] = '#';
      }
      return tiles;
    };

    generateWalls = function(floor) {
      var adjacent, c, floorCoor, key, wallCoor, x, y, _i, _len, _results;
      floorCoor = (function() {
        var _results;
        _results = [];
        for (key in floor) {
          _results.push(coorForKey(key));
        }
        return _results;
      })();
      adjacent = flatten((function() {
        var _i, _len, _ref, _results;
        _results = [];
        for (_i = 0, _len = floorCoor.length; _i < _len; _i++) {
          _ref = floorCoor[_i], x = _ref[0], y = _ref[1];
          _results.push(adjacentCoordinates(x, y));
        }
        return _results;
      })());
      wallCoor = (function() {
        var _i, _len, _ref, _results;
        _results = [];
        for (_i = 0, _len = adjacent.length; _i < _len; _i++) {
          _ref = adjacent[_i], x = _ref[0], y = _ref[1];
          if (floor[keyify(x, y)] !== '.') {
            _results.push([x, y]);
          }
        }
        return _results;
      })();
      _results = [];
      for (_i = 0, _len = wallCoor.length; _i < _len; _i++) {
        c = wallCoor[_i];
        _results.push(keyify.apply(null, c));
      }
      return _results;
    };

    drawLitTile = function(key, map) {
      var _ref;
      return (_ref = map.display).draw.apply(_ref, __slice.call(coorForKey(key)).concat([map.tiles[key]], ['#fff'], ['#660']));
    };

    keyify = function(x, y) {
      return x + ',' + y;
    };

    coorForKey = function(key) {
      return key.split(',').map(Number);
    };

    adjacentCoordinates = function(x, y) {
      var xi, yi, _i, _len, _ref, _ref1, _results;
      _ref = ROT.DIRS[8];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], xi = _ref1[0], yi = _ref1[1];
        _results.push([x + xi, y + yi]);
      }
      return _results;
    };

    flatten = function(a) {
      if (a.length === 0) {
        return [];
      }
      return a.reduce(function(lhs, rhs) {
        return lhs.concat(rhs);
      });
    };

    return Map;

  })();

}).call(this);
